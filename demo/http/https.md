#### http和https

##### 1. http 和 https 的基本概念

http： 是一个客户端和服务端请求和应答的标准（TCP）， 用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。
https： 是以安全为目标的 HTTP 通道， 即 HTTP 下 加入 SSL 层进行加密。其作用是： 建立一个信息安全通道， 来确保数据的传输， 确保网站的真实性。

##### 2. http 和 https 的优缺点？

- http 是超文本传输协议，信息是明文传输， HTTPS 协议要比http 协议安全， https 是具有安全性的ssl 加密传输协议， 可防止数据在传输过程中被窃取、改变 确保完整性

- http 默认端口 80 ， https默认端口 443

- http 的链接是无状态链接， https 握手阶段比较费事

- https 缓存不如http高效， 会增加数据开销

- https 需要 ca 证书，需要费用

- SSL 证书需要绑定 IP 不能在同一个 IP 上绑定多个域名

##### 3. https工作原理

客户端在使用 HTTPS 方式与 Web 服务器通信步骤

1. 客户端使用 HTTPS URL 访问服务器， 则要求web 服务器  *建立 SSL 链接*。
2. web 服务器接收到客户端请求之后，会 *将网站的证书（公钥），传输给客户端*。
3. 客户端和web服务器端开始 *协商 SSL 链接的安全等级*， 也就是加密等级。
4. 客户端浏览器通关双方协商一致的安全等级， *建立会话密钥* 然后通过网站的公钥来加密会话密钥，并传送给网站。
5. web 服务器 通过自己的密钥解密 会话密钥。
6. web 服务器 通过会话密钥加密加密与客户端之间的通信。

##### 4. TCP 三次握手

1. 第一次握手：  **建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列号**。
2. 第二次握手： **服务器收到 SYN 包并确认客户的syn（ack=j+1），同时也发送一个自己的 SYN 包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV 状态**。
3. 第三次握手： **客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（tcp连接成功）状态**

##### 5. TCP 四次挥手

1. 客户端进程发送链接释放报文， 客户端进入 终止等待1 状态；
2. 服务器收到报文，发送确认报文， 服务器进入半关闭状态；
3. 客户端收到服务确认请求后进入 终止等待2 状态；
4. 服务器将最后的数据发送完毕，就向客户端发送 释放报文， 此时服务器在最后确认状态；
5. 客户端收到释放报文之后 发送确认报文， 客户端进入等待状态 （等待最后撤销TCP才关闭）；
6. 服务器收到客户端发出的确认后， 立即进入关闭状态并撤销TCP， 然后客户端TCP断开


##### TCP/IP 如何确保数据包的有序可靠

对字节分流并进行编号然后 通过 ACK 回复和 超时重发 这两个机制来保证。

- 发送方必须吧已发送的数据包保留在缓存区；
- 并为每一个已发送的数据包启动一个超时定时器；
- 如果定时器超时之前收到了应答信息则释放该数据包占用的缓冲区；
- 否则，重传该数据包，直到收到应答或者超过规定重传次数
- 接收方收到数据包之后，先进行校验，如果正确就把数据交给上层协议，然后发送一个累积包，表明该数据已收到。

##### TCP 和 UDP 的区别

1. TCP 是面相链接的， UDP 是面相无链接
2. TCP仅支持单播传输， UDP 提供了单 多 广播的功能
3. TCP的三次握手保证了可靠性， UDP 无链接 不可靠
4. UDP 不需要链接所以传输速率更高，实效性更好

##### 跨域

跨域的原理

跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。
同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。
跨域原理，即是通过各种方式，避开浏览器的安全限制。


##### 浏览器 从 输入 URl 到页面加载全过程
1. 在浏览器中输入url 地址
2. 先在本机中 查找缓存， 浏览器和计算机都会有缓存
3. DNS域名解析 解析该地址的IP
4. 拿到IP 进行TCP链接
5. 发起HTTP 请求
6. 拿到请求数据浏览器执行渲染

##### 浏览器的重排 重绘

- 通过 添加、删除、更新 DOM 节点
- display：none 隐藏
- visibility：hidden-- 只触发重绘
- 移动或添加动画
- 添加样式表，调整样式属性
- 用户行为 窗口大小调整，改变字号，滚动

以上这些都会触发 浏览器的重排 重绘 

* 重排： 当DOM的变化影响了元素的几何信息，浏览器会重新计算各个元素的位置，这个过程就叫重排
* 重绘： 当一个元素发生外观变化，但没有改变布局，这个过程叫 重绘

「重绘」一定不会出现「重排」， 但「重排」必然会出现「重绘」


##### 浏览器的  强制缓存 && 协商缓存

浏览器与服务器通信方式为应答模式， 即是：浏览器发起http请求 - 服务器响应该请求。 那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，来决定是否缓存结果，是则将请求结果和缓存标识存入浏览器中，简单的过程如下图

[label](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/487144abaada4b9a8b34bc9375191ec7~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A1512%3A0%3A0%3A0.awebp)

由上图我们可以知道：
1. 浏览器每次发起请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识
2. 浏览器每次拿到返回的请求结果都会 将该结果和缓存标识存入浏览器缓存中

以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们在理解浏览器缓存的使用规范则，那么所有的问题就迎刃而解了。
为了方便理解，这里根据是否需要向服务器重新发起请求 将缓存过程分为两个部分， 分别是 强制缓存 和 协商缓存

* 强制缓存

   **强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。** 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的请求头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是， Expires 和 Cache-Control，其中Cache-Control 优先级比Expires高。

   强制缓存的情况主要有三种
   
   1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求
   2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，这使用协商缓存。
   3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。


* 协商缓存
  **协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器更具缓存标识决定是否使用缓存的过程。** 同样，协商缓存的标识也是在响应报文的HTTP头中和返回结果一起返回给浏览器的，协商缓存字段分别有： Last-Modufied / if-modufied-Since 和 Etag / If-None-Match , 其中 Etag / If-none-Match 的优先级比其他的两个高， 协商缓存主要有有一下两种情况。

  1. 协商缓存失效，返回304
  2. 协商缓存失效，返回200和请求结果


##### 进程、线程和协程

**进程**是一个具有独立功能的程序在一个数据集上动态执行的过程，**是操作系统进行资源分配的调度的一个独立单位**，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的定义。

**线程**是程序执行中一个单一的顺序控制流程，是**程序执行流的最小单元**，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间
打开的文件）和一个或多个线程组成。

**协程** 英文 Coroutines（循环器），是一种 **基于线程之上，但又比线程更加轻量级的存在**，这种由程序猿自己写程序来管理的轻量级线程这叫做「用户空间线程」，具有对内核来说不可见的特性。

进程和线程的区别与联系

「区别」: 
  调度： 线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
  并发性： 不仅进程之前可以并发执行，同一个进程的多个线程之间也可以并发执行；
  拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；
  系统开销： 在创建或撤销 **进程**时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或者撤销 **线程** 时的开销。
      但是进程有独立的地址空间，一个进程崩溃之后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。
      线程有自己的堆栈和局部变量，但是线程之间没有独立空间，一个进程死掉等于所有线程死掉，
      所以多进程的程序要比多线程的程序健壮， 但是在进程切换时，耗费资源较大，效率要差一些。

「联系」：
  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
  资源分配给进程，同一进程的所有线程共享改进程的所有资源；
  处理积分给线程，即真正在处理机上运行的上线程；
  线程在执行过程中，需要协作同步，不同的进程和线程间要利用消息通信的办法实现同步；


##### 事件循环 EventLoop

JS 是单线程的， 为了防止一个函数执行时间过长阻塞后面的代码执行，所以会将同步的代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，微任务先执行（Promise.then, axios...）， 宏任务后执行(setTimeOut(), setInterval)，

[Title](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

##### Node 环境中的事件环

Node 是基于V8引擎运行在服务端的 JavaScript 运行环境，在处理高并发、I/O密集（文件操作、网络操作、数据库操作等）场景有明显优势。虽然用到也是V8引擎，但由于服务器的目的和环境的不同，导致了他的API于原声JS有些区别，其 EventLoop 还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop与浏览器是不一样的
[Title](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

执行顺序如下：
 - timers: 计时器，执行SetTimeOut和SetInterval回调；
 - pending Callbacks： 执行延迟到下一个循环迭代的 I/O 回调；
 - idle， prepare： 队列的移动， 仅系统内部使用；
 - poll轮询： 检索新的i/o事件；执行与i/o 相关的回调。 事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在个阶段执行。
 - check： 执行setImmediate回调，setImmediate 在这里执行
 - close callbacks： 执行 close 事件的callback 一些关闭的回调函数